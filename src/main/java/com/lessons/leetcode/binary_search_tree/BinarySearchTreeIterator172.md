### –†–µ—à–µ–Ω–∏–µ. 1 –ø–æ–¥—Ö–æ–¥

## üìö –¶–µ–ª—å
–ö–ª–∞—Å—Å BSTIterator –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ—à–∞–≥–æ–≤–æ –æ–±—Ö–æ–¥–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø–æ–∏—Å–∫–∞ (BST) –≤ –ø–æ—Ä—è–¥–∫–µ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—è, —Ç–æ –µ—Å—Ç—å –≤ in-order traversal:
–ª–µ–≤–æ ‚Üí –∫–æ—Ä–µ–Ω—å ‚Üí –ø—Ä–∞–≤–æ

### üîπ –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä BSTIterator(TreeNode root)
```
stack = new ArrayDeque<>();
addLeftChilds(root);
```
–ß—Ç–æ –¥–µ–ª–∞–µ—Ç?
1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å—Ç–µ–∫.
2. –ö–ª–∞–¥—ë—Ç –≤ —Å—Ç–µ–∫ –≤—Å–µ—Ö –ª–µ–≤—ã—Ö –ø–æ—Ç–æ–º–∫–æ–≤, –Ω–∞—á–∏–Ω–∞—è —Å –∫–æ—Ä–Ω—è: –Ω–∞ –≤–µ—Ä—à–∏–Ω–µ —Å—Ç–µ–∫–∞ –±—É–¥–µ—Ç –Ω–∞–∏–º–µ–Ω—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç (–ª–µ–≤—ã–π –∫—Ä–∞–π –¥–µ—Ä–µ–≤–∞).
3. –ü–æ—á–µ–º—É? –ø—Ä–∏ in-order –æ–±—Ö–æ–¥–µ –ø–µ—Ä–≤—ã–º –¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è —Å–∞–º—ã–π –ª–µ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç.

### –ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã:
```
addLeftChilds(7):
‚Üí push 7
‚Üí move to 3
‚Üí push 3
‚Üí move to null ‚Üí –≤—ã—Ö–æ–¥

‚Üí —Å—Ç–µ–∫: [7, 3] (–≤–µ—Ä—Ö ‚Äî 3)
```

### üîπ –ú–µ—Ç–æ–¥ addLeftChilds(TreeNode node)
```
while (node != null) {
    stack.push(node);
    node = node.left;
}
```
–ß—Ç–æ –¥–µ–ª–∞–µ—Ç?
–≠—Ç–æ –∫–ª—é—á–µ–≤–∞—è —á–∞—Å—Ç—å: –æ–Ω–∞ –∏–¥—ë—Ç –ø–æ –ª–µ–≤—ã–º –ø–æ—Ç–æ–º–∫–∞–º –¥–µ—Ä–µ–≤–∞, –Ω–∞—á–∏–Ω–∞—è —Å node, –∏ –∫–ª–∞–¥—ë—Ç –∫–∞–∂–¥—ã–π —É–∑–µ–ª –≤ —Å—Ç–µ–∫.
–≠—Ç–æ –Ω—É–∂–Ω–æ, —á—Ç–æ–±—ã –Ω–∞ –≤–µ—Ä—à–∏–Ω–µ —Å—Ç–µ–∫–∞ –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥–∏–ª—Å—è —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ in-order –æ–±—Ö–æ–¥–µ.

–ö–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è?
1) –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ ‚Äî –¥–ª—è –Ω–∞—á–∞–ª—å–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏;

2) –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–Ω–æ–≥–æ —É–∑–ª–∞, –µ—Å–ª–∏ —É –Ω–µ–≥–æ –µ—Å—Ç—å –ø—Ä–∞–≤—ã–π –ø–æ—Ç–æ–º–æ–∫:
in-order: –æ–±—Ä–∞–±–æ—Ç–∞–ª–∏ –∫–æ—Ä–µ–Ω—å ‚Üí –∏–¥—ë–º –≤ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ.

### üîπ –ú–µ—Ç–æ–¥ next()
```
TreeNode current = stack.pop();       // –±–µ—Ä—ë–º —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç
addLeftChilds(current.right);         // –∏–¥—ë–º –≤ –µ–≥–æ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
return current.val;                   // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ
```

–†–∞–∑–±–æ—Ä:

1) –ë–µ—Ä—ë–º –≤–µ—Ä—Ö—É—à–∫—É —Å—Ç–µ–∫–∞ ‚Üí —ç—Ç–æ –Ω–∞–∏–º–µ–Ω—å—à–∏–π –µ—â—ë –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.
2) –ó–∞—Ç–µ–º:
–µ—Å–ª–∏ —É –Ω–µ–≥–æ –µ—Å—Ç—å –ø—Ä–∞–≤—ã–π —Ä–µ–±—ë–Ω–æ–∫, –º—ã –Ω–µ –∏–¥—ë–º —Ç—É–¥–∞ —Å—Ä–∞–∑—É.
–º—ã —Å–ø—É—Å–∫–∞–µ–º—Å—è –ø–æ –≤—Å–µ–º –ª–µ–≤—ã–º –æ—Ç current.right, –∫–ª–∞–¥—è –∏—Ö –≤ —Å—Ç–µ–∫.
3) –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ current.val.

–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —Å—Ç–µ–∫ –≤—Å–µ–≥–¥–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—É—Ç—å –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É in-order

### üîπ –ú–µ—Ç–æ–¥ hasNext()
```
return !stack.isEmpty();
```
–ü—Ä–æ–≤–µ—Ä–∫–∞:

–ï—Å—Ç—å –ª–∏ –µ—â—ë —ç–ª–µ–º–µ–Ω—Ç—ã?
–ï—Å–ª–∏ —Å—Ç–µ–∫ –Ω–µ –ø—É—Å—Ç, —Ç–æ –∑–Ω–∞—á–∏—Ç, —Å–ª–µ–¥—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç —É–∂–µ –≥–æ—Ç–æ–≤.

### –ü—Ä–∏–º–µ—Ä —Ä–∞–±–æ—Ç—ã:

```
     7
    / \
   3   15
      /  \
     9    20
```

| –û–ø–µ—Ä–∞—Ü–∏—è    | –°—Ç–µ–∫ (–≤–µ—Ä—Ö —Å–ø—Ä–∞–≤–∞) | –í—ã–≤–æ–¥ | –ü–æ—è—Å–Ω–µ–Ω–∏–µ                                            |
|-------------|--------------------|-------|------------------------------------------------------|
| start       | \[7, 3]            |       | –ø–æ—Å–ª–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞                                   |
| `next()`    | \[7]               | 3     | pop(3), 3 –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∞–≤–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤–∞                 |
| `next()`    | \[15, 9]           | 7     | pop(7), –≤—ã–∑—ã–≤–∞–µ–º `addLeftChilds(15)` ‚Üí —Å—Ç–µ–∫ += 15, 9 |
| `next()`    | \[15]              | 9     | pop(9), –Ω–µ—Ç –ø—Ä–∞–≤–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤–∞                        |
| `next()`    | \[20]              | 15    | pop(15), –≤—ã–∑—ã–≤–∞–µ–º `addLeftChilds(20)`                |
| `next()`    | \[]                | 20    | pop(20), –Ω–µ—Ç –ø—Ä–∞–≤–æ–≥–æ                                 |
| `hasNext()` | \[]                | false | —Å—Ç–µ–∫ –ø—É—Å—Ç                                            |

### –†–µ—à–µ–Ω–∏–µ
## Java
```
class BSTIterator {

    private Deque<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        stack = new ArrayDeque<>();
        addLeftChilds(root);
    }

    public int next() {
        TreeNode current = stack.pop();
        addLeftChilds(current.right);
        return current.val;
    }

    public boolean hasNext() {
        return !stack.isEmpty();
    }

    private void addLeftChilds(TreeNode node) {
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
    }
}
```

## Kotlin
```
import java.util.ArrayDeque

class BSTIterator(root: TreeNode?) {

    private val stack = ArrayDeque<TreeNode>()

    init {
        addLeftChildren(root)
    }

    fun next(): Int {
        val current = stack.pop()
        addLeftChildren(current.right)
        return current.`val`
    }

    fun hasNext(): Boolean {
        return stack.isNotEmpty()
    }

    private fun addLeftChildren(node: TreeNode?) {
        var curr = node
        while (curr != null) {
            stack.push(curr)
            curr = curr.left
        }
    }
}
```